# Complete Architecture Overview

## ğŸ—ï¸ System Components

### 1. **.NET Server** (Main Backend)
- **Port**: 5262 (HTTP) / 5001 (HTTPS)
- **Purpose**: Main API server, handles all business logic
- **Token Generation**: `api/realtime/token` endpoint
- **Uses**: `AgoraTokenService` to generate tokens
- **Redis**: Caches tokens to avoid regenerating them (1 hour expiration)

### 2. **.NET Client** (Blazor Web App)
- **Purpose**: Web interface for doctors/patients
- **Calls**: `.NET Server` for tokens via `api/realtime/token`
- **Authentication**: Uses JWT tokens from browser storage

### 3. **Mobile App** (React Native)
- **Purpose**: Mobile interface for patients
- **Calls**: `.NET Server` for tokens via `http://YOUR_IP:5262/api/realtime/token`
- **Authentication**: Uses JWT tokens from AsyncStorage

### 4. **Redis** (Caching Layer)
- **Port**: 6379
- **Purpose**: 
  - Cache Agora tokens (avoid regenerating same token)
  - Cache expires after 1 hour (3600 seconds)
  - Key format: `agora_token:{channel}:{uid}`
- **Why**: Tokens are expensive to generate, caching improves performance

### 5. **Agora** (Video/Audio Service)
- **Purpose**: Handles actual video/audio calls
- **Requires**: Valid token for each channel/UID combination
- **Token**: Generated by .NET server, cached in Redis

## ğŸ”„ Token Generation Flow

```
1. User initiates call (Mobile or Web)
   â†“
2. Client requests token from .NET Server
   GET /api/realtime/token?channel=call_1_2&uid=1
   â†“
3. .NET Server checks Redis cache
   - If cached â†’ return cached token âœ…
   - If not cached â†’ generate new token â†’ cache it â†’ return it âœ…
   â†“
4. Client receives token
   â†“
5. Client joins Agora channel with token
   â†“
6. Agora validates token and connects users
```

## ğŸ¯ Why Redis Caching?

- **Performance**: Token generation is CPU-intensive (HMAC-SHA256 signing)
- **Consistency**: Same channel/UID gets same token (reduces connection issues)
- **Efficiency**: Tokens are valid for 1 hour, no need to regenerate
- **Cost**: Reduces server load

## ğŸ“ Current Setup (After Fix)

âœ… **All clients use .NET Server** for token generation:
- Blazor Web App â†’ `api/realtime/token` (relative URL)
- Mobile App â†’ `http://YOUR_IP:5262/api/realtime/token`

âŒ **Node.js Token Server** (`AgoraTokenServer/server.js`):
- **NOT USED** - Can be removed or kept as backup
- Was an alternative implementation, but .NET server is preferred

## ğŸ”§ What You Need Running

1. **Redis** (required)
   ```bash
   # If using Docker:
   docker run -d -p 6379:6379 redis:alpine redis-server --requirepass StrongPassword123!
   ```

2. **.NET Server** (required)
   ```bash
   cd SM_MentalHealthApp.Server
   dotnet run
   ```

3. **.NET Client** (for web app)
   ```bash
   cd SM_MentalHealthApp.Client
   dotnet run
   ```

4. **Mobile App** (for mobile)
   ```bash
   cd MentalHealthMobileClean
   npm start
   ```

## ğŸš« What You DON'T Need

- âŒ **Node.js Token Server** - Not needed, .NET server handles it
- âŒ **Separate token service** - Everything goes through .NET server

## ğŸ” Authentication Flow

1. User logs in â†’ Gets JWT token
2. Client stores JWT token (browser storage / AsyncStorage)
3. Client requests Agora token â†’ Includes JWT in Authorization header
4. .NET Server validates JWT â†’ Generates Agora token â†’ Returns it
5. Client uses Agora token to join video/audio call

## ğŸ’¡ Key Points

- **One Backend**: .NET Server handles everything
- **Redis Caching**: Improves performance, reduces token generation
- **Consistent**: All clients use same endpoint
- **Secure**: JWT authentication required
- **Simple**: No need for separate Node.js server

