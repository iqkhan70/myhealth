@using SM_MentalHealthApp.Client.Services
@using SM_MentalHealthApp.Client.Components
@inherits LayoutComponentBase
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject IAuthService AuthService
@inject ISignalRService SignalRService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@if (!AuthService.IsInitialized)
{
    <div class="loading-container">
        <div class="loading-spinner"></div>
        <p>Loading...</p>
    </div>
}
else
{
    <div class="rz-layout">
        <!-- Header with logout button -->
        @if (AuthService.CurrentUser != null)
        {
            <div class="app-header">
                <div class="header-content">
                    <div class="app-title">
                        <h1>Customer Health App</h1>
                    </div>
                    <div class="header-user-info">
                        <div class="user-details">
                            <span class="user-name">@AuthService.CurrentUser.FullName</span>
                            <span class="user-email">@AuthService.CurrentUser.Email</span>
                        </div>
                        <button class="header-logout-btn" @onclick="Logout" title="Logout">
                            <i class="nav-icon">🚪</i>
                            <span>Logout</span>
                        </button>
                    </div>
                </div>
            </div>
        }

        <div class="rz-layout-main">
            <div class="rz-layout-sidebar">
                <NavMenu />
            </div>

            <div class="rz-layout-body">
                <div class="rz-layout-content">
                    @Body
                </div>
            </div>
        </div>
    </div>
}

<!-- Radzen Notification Component - Required for notifications to display -->
<RadzenNotification />

<!-- Radzen Dialog Component - Required for dialogs to display -->
<RadzenDialog />

<!-- Incoming Call Modal -->
<IncomingCallModal IncomingCall="@incomingCall" OnCallAccepted="@HandleCallAccepted"
    OnCallDeclined="@HandleCallDeclined" />


@code {
    private CallInvitation? incomingCall;

    protected override async Task OnInitializedAsync()
    {
        // Set up SignalR event handlers
        SignalRService.OnIncomingCall += HandleIncomingCall;
        SignalRService.OnNewMessage += HandleNewMessage;
        SignalRService.OnCallEnded += HandleCallEnded;

        // Start SignalR connection if user is authenticated
        if (AuthService.CurrentUser != null)
        {
            await SignalRService.StartAsync();
        }
    }

    private void HandleIncomingCall(CallInvitation call)
    {
        // Filter calls - only show if this user is the target
        var currentUserId = AuthService.CurrentUser?.Id;
        if (currentUserId == null || call.TargetUserId != currentUserId)
        {
            return;
        }

        incomingCall = call;
        InvokeAsync(StateHasChanged);

        // Show notification
        NotificationService.Notify(NotificationSeverity.Info, "Incoming Call",
        $"{call.CallType} call from {call.CallerName}");
    }

    private void HandleNewMessage(ChatMessage message)
    {
        // Show notification for new messages
        NotificationService.Notify(NotificationSeverity.Info, "New Message",
        $"Message from {message.SenderName}");
    }


    private async void HandleCallEnded(string callIdOrChannel)
    {
        
        // ✅ If there's an incoming call, close it when we receive call-ended event
        // The server sends channelName in call-ended, and incomingCall.CallId is the channel name
        // Use case-insensitive matching and also close if IDs match or if either is empty (fallback)
        if (incomingCall != null)
        {
            var callIdMatch = string.IsNullOrEmpty(incomingCall.CallId) || 
                            string.IsNullOrEmpty(callIdOrChannel) ||
                            incomingCall.CallId.Equals(callIdOrChannel, StringComparison.OrdinalIgnoreCase) ||
                            callIdOrChannel.Equals(incomingCall.CallId, StringComparison.OrdinalIgnoreCase) ||
                            callIdOrChannel.Contains(incomingCall.CallId, StringComparison.OrdinalIgnoreCase) ||
                            incomingCall.CallId.Contains(callIdOrChannel, StringComparison.OrdinalIgnoreCase);
            
            if (callIdMatch)
            {
                // ✅ Stop ringtone when call ends (timeout or manual end)
                try
                {
                    await JSRuntime.InvokeVoidAsync("stopIncomingCallSound");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"⚠️ MainLayout: Error stopping ringtone: {ex.Message}");
                }
                
                incomingCall = null;
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                // ✅ FALLBACK: If there's an incoming call and we get a call-ended event, close it anyway
                // This handles cases where the channel name might be slightly different
                try
                {
                    await JSRuntime.InvokeVoidAsync("stopIncomingCallSound");
                }
                catch { }
                incomingCall = null;
                await InvokeAsync(StateHasChanged);
                Console.WriteLine($"✅ MainLayout: Dialog closed via fallback");
            }
        }
        else
        {
            Console.WriteLine($"📞 MainLayout: No incoming call to close (incomingCall is null)");
        }
    }

    private async Task HandleCallAccepted(CallInvitation call)
    {
        incomingCall = null;

        try
        {
            // ✅ Pass the channel name in query string so the call page can auto-join
            // The CallId is the channel name (e.g., "call_2_3")
            var channelName = call.CallId ?? "";
            
            // ✅ Validate channel name - if empty, generate one based on caller and current user
            if (string.IsNullOrWhiteSpace(channelName))
            {
                var currentUserId = AuthService.CurrentUser?.Id ?? 0;
                var callerId = call.CallerId;
                if (currentUserId > 0 && callerId > 0)
                {
                    var smallerId = Math.Min(currentUserId, callerId);
                    var largerId = Math.Max(currentUserId, callerId);
                    channelName = $"call_{smallerId}_{largerId}";
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Call Error",
                    "Cannot join call: missing channel information");
                    return;
                }
            }
                        
            // Navigate to the video call page to join the call
            var callUrl = call.CallType?.ToLower() == "video"
            ? $"/video-call/{call.CallerId}?channel={Uri.EscapeDataString(channelName)}"
            : $"/audio-call/{call.CallerId}?channel={Uri.EscapeDataString(channelName)}";

            NotificationService.Notify(NotificationSeverity.Success, "Call Accepted",
            $"Joining {call.CallType} call with {call.CallerName}...");

            Navigation.NavigateTo(callUrl);
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Call Error",
            $"Failed to join call: {ex.Message}");
        }

        StateHasChanged();
    }

    private async Task HandleCallDeclined(CallInvitation call)
    {
        // ✅ Stop ringtone when call is declined
        try
        {
            await JSRuntime.InvokeVoidAsync("stopIncomingCallSound");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ MainLayout: Error stopping ringtone: {ex.Message}");
        }
        
        incomingCall = null;
        await InvokeAsync(StateHasChanged);
    }

    private void ShowAbout()
    {
        DialogService.Open("About", ds =>
        @<div>
            <RadzenText TextStyle="TextStyle.H4" Text="Customer Health App" />
            <RadzenText Text="A compassionate AI-powered journaling app for health tracking and support." />
            <RadzenText Text="Built with Blazor WebAssembly and powered by Hugging Face AI models." />
        </div>,
        new DialogOptions() { Width = "500px", Resizable = true, Draggable = true });
    }

    private async Task Logout()
    {
        try
        {
            // ✅ Stop SignalR connection
            await SignalRService.StopAsync();
            
            // ✅ Clear authentication state
            await AuthService.LogoutAsync();
            
            // ✅ Force full page reload to clear all component state and cached data
            // This ensures no data from previous user persists
            await JSRuntime.InvokeVoidAsync("eval", "window.location.href = '/login'");
        }
        catch (Exception ex)
        {
            // If JS interop fails, fallback to navigation
            Console.WriteLine($"Error during logout: {ex.Message}");
            Navigation.NavigateTo("/login", forceLoad: true);
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Clean up event handlers
        SignalRService.OnIncomingCall -= HandleIncomingCall;
        SignalRService.OnNewMessage -= HandleNewMessage;
        SignalRService.OnCallEnded -= HandleCallEnded;

        await SignalRService.StopAsync();
    }
}
