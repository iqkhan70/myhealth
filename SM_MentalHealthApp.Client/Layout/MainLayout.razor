@using SM_MentalHealthApp.Client.Services
@using SM_MentalHealthApp.Client.Components
@inherits LayoutComponentBase
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject IAuthService AuthService
@inject ISignalRService SignalRService
@inject IRealtimeService RealtimeService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@if (!AuthService.IsInitialized)
{
    <div class="loading-container">
        <div class="loading-spinner"></div>
        <p>Loading...</p>
    </div>
}
else
{
    <div class="rz-layout">
        <!-- Header with logout button -->
        @if (AuthService.CurrentUser != null)
        {
            <div class="app-header">
                <div class="header-content">
                    <div class="app-title">
                        <h1>Customer Support App</h1>
                    </div>
                    <div class="header-user-info">
                        <div class="user-details">
                            <span class="user-name">@AuthService.CurrentUser.FullName</span>
                            <span class="user-email">@AuthService.CurrentUser.Email</span>
                        </div>
                        <button class="header-logout-btn" @onclick="Logout" title="Logout">
                            <i class="nav-icon">🚪</i>
                            <span>Logout</span>
                        </button>
                    </div>
                </div>
            </div>
        }

        <div class="rz-layout-main">
            <div class="rz-layout-sidebar">
                <NavMenu />
            </div>

            <div class="rz-layout-body">
                <div class="rz-layout-content">
                    @Body
                </div>
            </div>
        </div>
    </div>
}

<!-- Radzen Notification Component - Required for notifications to display -->
<RadzenNotification />

<!-- Radzen Dialog Component - Required for dialogs to display -->
<RadzenDialog />

<!-- Incoming Call Modal -->
<IncomingCallModal IncomingCall="@incomingCall" OnCallAccepted="@HandleCallAccepted"
    OnCallDeclined="@HandleCallDeclined" />


@code {
    private CallInvitation? incomingCall;
    private HashSet<string> rejectedCallIds = new(); // Track rejected calls to prevent re-showing

    protected override async Task OnInitializedAsync()
    {
        // Set up SignalR event handlers (for mobile-to-web calls)
        SignalRService.OnIncomingCall += HandleIncomingCall;
        SignalRService.OnNewMessage += HandleNewMessage;
        SignalRService.OnCallEnded += HandleCallEnded;
        SignalRService.OnCallRejected += HandleCallRejected;

        // ✅ ALSO set up RealtimeService event handlers (for web-to-web calls)
        RealtimeService.OnIncomingCall += HandleIncomingCall;
        RealtimeService.OnCallEnded += HandleCallEnded;
        RealtimeService.OnCallRejected += HandleCallRejected;

        // Start SignalR connection if user is authenticated
        if (AuthService.CurrentUser != null)
        {
            await SignalRService.StartAsync();
            // RealtimeService will be started when needed (e.g., when user navigates to RealTimeChat)
        }
    }

    private void HandleIncomingCall(CallInvitation call)
    {
        var currentUserId = AuthService.CurrentUser?.Id;
        if (currentUserId == null)
        {
            Console.WriteLine($"📞 MainLayout: Ignoring incoming call - user not authenticated");
            return;
        }

        // ✅ CRITICAL: Don't show incoming call modal if this user is the caller (they initiated the call)
        if (call.CallerId == currentUserId)
        {
            Console.WriteLine($"📞 MainLayout: Ignoring incoming call - user {currentUserId} is the caller (they initiated this call)");
            return;
        }

        // ✅ Filter calls - only show if this user is the target
        // If TargetUserId is set, use it; otherwise, assume any call where we're not the caller is for us
        if (call.TargetUserId > 0 && call.TargetUserId != currentUserId)
        {
            Console.WriteLine($"📞 MainLayout: Ignoring incoming call - TargetUserId {call.TargetUserId} doesn't match current user {currentUserId}");
            return;
        }

        // ✅ CRITICAL: Don't show if we already have this exact call (prevent duplicates)
        if (incomingCall != null && incomingCall.CallId == call.CallId)
        {
            Console.WriteLine($"📞 MainLayout: Ignoring duplicate incoming call - already showing call {call.CallId}");
            return;
        }

        // ✅ CRITICAL: Don't show if this call was already rejected by the user
        if (rejectedCallIds.Contains(call.CallId))
        {
            Console.WriteLine($"📞 MainLayout: Ignoring incoming call - call {call.CallId} was already rejected");
            return;
        }

        Console.WriteLine($"📞 MainLayout: Showing incoming call modal for call from {call.CallerName} (CallerId: {call.CallerId}, TargetUserId: {call.TargetUserId}, CurrentUserId: {currentUserId}, CallId: {call.CallId})");
        incomingCall = call;
        InvokeAsync(StateHasChanged);

        // Show notification
        NotificationService.Notify(NotificationSeverity.Info, "Incoming Call",
        $"{call.CallType} call from {call.CallerName}");
    }

    private void HandleCallRejected(string callId)
    {
        Console.WriteLine($"📞 MainLayout: HandleCallRejected called for callId: {callId}");
        
        // ✅ Mark this call as rejected to prevent it from being shown again
        if (!string.IsNullOrEmpty(callId))
        {
            rejectedCallIds.Add(callId);
            Console.WriteLine($"✅ MainLayout: Added {callId} to rejectedCallIds (total: {rejectedCallIds.Count})");
        }
        
        // ✅ If the rejected call matches our incoming call, clear it immediately
        if (incomingCall != null && 
            (incomingCall.CallId == callId || 
             callId.Contains(incomingCall.CallId) || 
             incomingCall.CallId.Contains(callId)))
        {
            Console.WriteLine($"📞 MainLayout: Call {callId} was rejected, clearing incoming call modal");
            incomingCall = null;
            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleNewMessage(ChatMessage message)
    {
        // Show notification for new messages
        NotificationService.Notify(NotificationSeverity.Info, "New Message",
        $"Message from {message.SenderName}");
    }


    private async void HandleCallEnded(string callIdOrChannel)
    {
        
        // ✅ If there's an incoming call, close it when we receive call-ended event
        // The server sends channelName in call-ended, and incomingCall.CallId is the channel name
        // Use case-insensitive matching and also close if IDs match or if either is empty (fallback)
        if (incomingCall != null)
        {
            var callIdMatch = string.IsNullOrEmpty(incomingCall.CallId) || 
                            string.IsNullOrEmpty(callIdOrChannel) ||
                            incomingCall.CallId.Equals(callIdOrChannel, StringComparison.OrdinalIgnoreCase) ||
                            callIdOrChannel.Equals(incomingCall.CallId, StringComparison.OrdinalIgnoreCase) ||
                            callIdOrChannel.Contains(incomingCall.CallId, StringComparison.OrdinalIgnoreCase) ||
                            incomingCall.CallId.Contains(callIdOrChannel, StringComparison.OrdinalIgnoreCase);
            
            if (callIdMatch)
            {
                // ✅ Stop ringtone when call ends (timeout or manual end)
                try
                {
                    await JSRuntime.InvokeVoidAsync("stopIncomingCallSound");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"⚠️ MainLayout: Error stopping ringtone: {ex.Message}");
                }
                
                incomingCall = null;
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                // ✅ FALLBACK: If there's an incoming call and we get a call-ended event, close it anyway
                // This handles cases where the channel name might be slightly different
                try
                {
                    await JSRuntime.InvokeVoidAsync("stopIncomingCallSound");
                }
                catch { }
                incomingCall = null;
                await InvokeAsync(StateHasChanged);
                Console.WriteLine($"✅ MainLayout: Dialog closed via fallback");
            }
        }
        else
        {
            Console.WriteLine($"📞 MainLayout: No incoming call to close (incomingCall is null)");
        }
    }

    private async Task HandleCallAccepted(CallInvitation call)
    {
        incomingCall = null;

        try
        {
            // ✅ Pass the channel name in query string so the call page can auto-join
            // The CallId is the channel name (e.g., "call_2_3")
            var channelName = call.CallId ?? "";
            
            // ✅ Validate channel name - if empty, generate one based on caller and current user
            if (string.IsNullOrWhiteSpace(channelName))
            {
                var currentUserId = AuthService.CurrentUser?.Id ?? 0;
                var callerId = call.CallerId;
                if (currentUserId > 0 && callerId > 0)
                {
                    var smallerId = Math.Min(currentUserId, callerId);
                    var largerId = Math.Max(currentUserId, callerId);
                    channelName = $"call_{smallerId}_{largerId}";
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Call Error",
                    "Cannot join call: missing channel information");
                    return;
                }
            }
                        
            // Navigate to the video call page to join the call
            var callUrl = call.CallType?.ToLower() == "video"
            ? $"/video-call/{call.CallerId}?channel={Uri.EscapeDataString(channelName)}"
            : $"/audio-call/{call.CallerId}?channel={Uri.EscapeDataString(channelName)}";

            NotificationService.Notify(NotificationSeverity.Success, "Call Accepted",
            $"Joining {call.CallType} call with {call.CallerName}...");

            Navigation.NavigateTo(callUrl);
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Call Error",
            $"Failed to join call: {ex.Message}");
        }

        StateHasChanged();
    }

    private async Task HandleCallDeclined(CallInvitation call)
    {
        Console.WriteLine($"📞 MainLayout: HandleCallDeclined called for call {call.CallId}");
        
        // ✅ CRITICAL: Mark this call as rejected IMMEDIATELY to prevent it from being shown again
        if (!string.IsNullOrEmpty(call.CallId))
        {
            rejectedCallIds.Add(call.CallId);
            Console.WriteLine($"✅ MainLayout: Added {call.CallId} to rejectedCallIds (total: {rejectedCallIds.Count})");
        }
        
        // ✅ CRITICAL: Clear the incoming call state IMMEDIATELY to prevent it from reappearing
        // Do this BEFORE any async operations to prevent race conditions
        if (incomingCall != null && incomingCall.CallId == call.CallId)
        {
            incomingCall = null;
            StateHasChanged(); // Update UI immediately
            Console.WriteLine($"✅ MainLayout: Cleared incoming call state for {call.CallId}");
        }
        
        // ✅ Stop ringtone when call is declined
        try
        {
            await JSRuntime.InvokeVoidAsync("stopIncomingCallSound");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ MainLayout: Error stopping ringtone: {ex.Message}");
        }
        
        // Ensure state is updated
        await InvokeAsync(StateHasChanged);
    }

    private void ShowAbout()
    {
        DialogService.Open("About", ds =>
        @<div>
            <RadzenText TextStyle="TextStyle.H4" Text="Customer Support App" />
            <RadzenText Text="A compassionate AI-powered journaling app for health tracking and support." />
            <RadzenText Text="Built with Blazor WebAssembly and powered by Hugging Face AI models." />
        </div>,
        new DialogOptions() { Width = "500px", Resizable = true, Draggable = true });
    }

    private async Task Logout()
    {
        try
        {
            // ✅ Stop SignalR connection
            await SignalRService.StopAsync();
            
            // ✅ Clear authentication state
            await AuthService.LogoutAsync();
            
            // ✅ Force full page reload to clear all component state and cached data
            // This ensures no data from previous user persists
            await JSRuntime.InvokeVoidAsync("eval", "window.location.href = '/login'");
        }
        catch (Exception ex)
        {
            // If JS interop fails, fallback to navigation
            Console.WriteLine($"Error during logout: {ex.Message}");
            Navigation.NavigateTo("/login", forceLoad: true);
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Clean up event handlers
        SignalRService.OnIncomingCall -= HandleIncomingCall;
        SignalRService.OnNewMessage -= HandleNewMessage;
        SignalRService.OnCallEnded -= HandleCallEnded;
        SignalRService.OnCallRejected -= HandleCallRejected;

        // ✅ Also clean up RealtimeService event handlers
        RealtimeService.OnIncomingCall -= HandleIncomingCall;
        RealtimeService.OnCallEnded -= HandleCallEnded;
        RealtimeService.OnCallRejected -= HandleCallRejected;

        await SignalRService.StopAsync();
    }
}
