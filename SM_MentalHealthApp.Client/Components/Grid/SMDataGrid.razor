@using Radzen
@using Radzen.Blazor
@using SM_MentalHealthApp.Shared
@using System
@inherits ComponentBase
@typeparam TItem

@if (ShowErrorAlert && !string.IsNullOrWhiteSpace(_errorMessage))
{
    <RadzenAlert AlertStyle="AlertStyle.Danger" Icon="error" Text="@_errorMessage" Style="margin-bottom: 1rem;" />
}

@if (_isLoading)
{
    <RadzenProgressBarLinear ShowValue="false" Mode="ProgressBarMode.Indeterminate" Style="margin-bottom: 1rem; height: 4px;" />
}

<div style="position: relative;">
    @if (_isLoading)
    {
        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.7); z-index: 10; display: flex; align-items: center; justify-content: center; pointer-events: none;">
            <RadzenProgressBarCircular Mode="ProgressBarMode.Indeterminate" Style="width: 50px; height: 50px;" />
        </div>
    }
    <RadzenDataGrid TItem="TItem" 
    @ref="_radzenGrid"
    Data="@_items"
    Count="@(UseServerSidePagination ? _totalCount : _items.Count)"
    LoadData="@(UseServerSidePagination ? LoadData : null)" 
    class="@Class" 
    AllowAlternatingRows="@AllowAlternatingRows"
    AllowFiltering="@AllowFiltering" 
    GridLines="@GridLines" 
    AllowColumnResize="@AllowColumnResize"
    FilterMode="@FilterMode" 
    FilterCaseSensitivity="FilterCaseSensitivity.CaseInsensitive"
    AllowSorting="@AllowSorting" 
    PageSize="@PageSize" 
    AllowPaging="@AllowPaging"
    PagerHorizontalAlign="@PagerHorizontalAlign" 
    ShowPagingSummary="@ShowPagingSummary" 
    ColumnWidth="@ColumnWidth"
    LogicalFilterOperator="@LogicalFilterOperator" 
    SelectionMode="@SelectionMode"
    RowExpand="@(item => HandleRowExpand(item))" 
    @attributes="AdditionalAttributes">
    <Columns>
        @if (ChildContent is not null)
        {
            @ChildContent
        }
        else if (Columns is not null)
        {
            foreach (var col in Columns)
            {
                @switch (col)
                {
                    case SMDataGridBadgeColumn<TItem> badgeCol:
                        <RadzenDataGridColumn TItem="TItem" Property="@col.Property" Title="@col.Title" Width="@col.Width"
                            TextAlign="@(col.TextAlign ?? TextAlign.Left)" Sortable="@(col.Sortable ?? true)"
                            Filterable="@(col.Filterable ?? true)">
                            <Template Context="data">
                                @{
                                    var badgeData = badgeCol.GetBadgeData(data);
                                }
                                @if (badgeData.HasBadgeText)
                                {
                                    <RadzenBadge BadgeStyle="@(badgeData.BadgeStyle == NotificationSeverity.Success ? BadgeStyle.Success : 
                                                                                                               badgeData.BadgeStyle == NotificationSeverity.Error ? BadgeStyle.Danger :
                                                                                                               badgeData.BadgeStyle == NotificationSeverity.Warning ? BadgeStyle.Warning :
                                                                                                               BadgeStyle.Info)" Text="@badgeData.BadgeText" />
                                }
                            </Template>
                        </RadzenDataGridColumn>
                        break;

                    case SMDataGridTextAndBadgeColumn<TItem> textAndBadgeCol:
                        <RadzenDataGridColumn TItem="TItem" Property="@col.Property" Title="@col.Title" Width="@col.Width"
                            TextAlign="@(col.TextAlign ?? TextAlign.Left)" Sortable="@(col.Sortable ?? true)"
                            Filterable="@(col.Filterable ?? true)">
                            <Template Context="data">
                                <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.SpaceBetween"
                                    AlignItems="AlignItems.Normal" class="rz-pb-2">
                                    @{
                                        var textAndBadgeData = textAndBadgeCol.GetTextAndBadgeData(data);
                                    }
                                    <span>@textAndBadgeData.Text</span>
                                    @if (textAndBadgeData.ShouldDisplayBadge && textAndBadgeData.HasBadgeText)
                                    {
                                        <RadzenBadge BadgeStyle="@(textAndBadgeData.BadgeStyle == NotificationSeverity.Success ? BadgeStyle.Success : 
                                                                                                                       textAndBadgeData.BadgeStyle == NotificationSeverity.Error ? BadgeStyle.Danger :
                                                                                                                       textAndBadgeData.BadgeStyle == NotificationSeverity.Warning ? BadgeStyle.Warning :
                                                                                                                       BadgeStyle.Info)"
                        Text="@textAndBadgeData.BadgeText" />
                                        }
                                </RadzenStack>
                            </Template>
                        </RadzenDataGridColumn>
                        break;

                    case SMDataGridTemplateColumn<TItem> templateCol:
                        <RadzenDataGridColumn TItem="TItem" Property="@col.Property" Title="@col.Title" Width="@col.Width"
                            TextAlign="@(col.TextAlign ?? TextAlign.Left)" Sortable="@(col.Sortable ?? true)"
                            Filterable="@(col.Filterable ?? true)">
                            <Template Context="data">
                                @if (templateCol.Template is not null)
                                {
                                    @templateCol.Template(data)
                                }
                            </Template>
                        </RadzenDataGridColumn>
                        break;

                    default:
                        <RadzenDataGridColumn TItem="TItem" Property="@col.Property" Title="@col.Title" Width="@col.Width"
                            TextAlign="@(col.TextAlign ?? TextAlign.Left)" Sortable="@(col.Sortable ?? true)"
                            Filterable="@(col.Filterable ?? true)" />
                        break;
                }
            }
        }

        @if (Actions is not null && Actions.Count > 0)
        {
            <RadzenDataGridColumn TItem="TItem" Title="@ActionsTitle" Sortable="false" Filterable="false"
                Width="@ActionsWidth" TextAlign="@ActionsTextAlign">
                <Template Context="row">
                    <div style="display: flex; justify-content: center; align-items: center; gap: 5px;">
                        @foreach (var action in Actions)
                        {
                            // Only render button if it's visible for this row
                            if (action.IsVisible(row))
                            {
                                var disabled = (DisableActionsWhileLoading && _isLoading) || (action.Disabled?.Invoke(row) ??
                                false);
                                <RadzenButton Icon="@action.GetIcon(row)" ButtonStyle="@action.GetButtonStyle(row)" Variant="@action.Variant"
                                    Size="@action.Size" Disabled="@disabled"
                                    Click="@(async () => await InvokeRowActionAsync(action, row))" @onclick:stopPropagation="true"
                                    Title="@action.GetTooltip(row)" class="mr-1" />
                            }
                        }
                    </div>
                </Template>
            </RadzenDataGridColumn>
        }
    </Columns>

    <Template Context="item">
        @if (ExpansionTemplate is not null)
        {
            @ExpansionTemplate(item)
        }
    </Template>
</RadzenDataGrid>
</div>

@code {
    private List<TItem> _items = new();
    private int _totalCount = 0;
    private CancellationTokenSource? _cts;
    private bool _isLoading;
    private string? _errorMessage;
    private RadzenDataGrid<TItem>? _radzenGrid;
    
    // Determine if we're using server-side pagination
    private bool UseServerSidePagination => LoadItemsPaged is not null;

    protected override async Task OnInitializedAsync()
    {
        _cts = new CancellationTokenSource();
        
        // For server-side pagination, start with empty list so LoadData gets called
        if (UseServerSidePagination)
        {
            _items = new List<TItem>();
            _totalCount = 0;
        }
        
        // If using client-side pagination (LoadItems), load data on init
        if (!UseServerSidePagination && LoadItems is not null && AutoLoad)
        {
            await LoadAllItemsAsync(_cts.Token);
        }
        // If using server-side pagination, RadzenDataGrid will call LoadData automatically on first render
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // For server-side pagination, RadzenDataGrid should call LoadData automatically
        // If it doesn't, we can trigger it by explicitly calling Reload
        if (firstRender && UseServerSidePagination && LoadItemsPaged is not null && _radzenGrid != null)
        {
            // Small delay to ensure grid is fully rendered, then trigger reload
            await Task.Delay(100);
            if (_radzenGrid != null)
            {
                await _radzenGrid.Reload();
            }
        }
    }
    
    private async Task LoadAllItemsAsync(CancellationToken ct)
    {
        if (_isLoading || LoadItems is null) return;

        _isLoading = true;
        _errorMessage = null;

        try
        {
            var items = await LoadItems(ct);
            _items = items?.ToList() ?? new();

            if (OnItemsLoaded.HasDelegate)
            {
                await OnItemsLoaded.InvokeAsync(_items);
            }
        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
            if (OnLoadError.HasDelegate)
            {
                await OnLoadError.InvokeAsync(ex);
            }
        }
        finally
        {
            _isLoading = false;
            if (!ct.IsCancellationRequested)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    public async Task RefreshAsync()
    {
        if (_cts is null) return;
        
        if (UseServerSidePagination)
        {
            // For server-side pagination, reset and explicitly trigger Radzen to reload
            _totalCount = 0;
            _items.Clear();
            
            // Explicitly reload the RadzenDataGrid to trigger LoadData
            // This must be done before StateHasChanged to ensure Radzen sees the change
            if (_radzenGrid != null)
            {
                await _radzenGrid.Reload();
            }
            
            await InvokeAsync(StateHasChanged);
        }
        else
        {
            // For client-side pagination, reload all items
            await LoadAllItemsAsync(_cts.Token);
        }
    }

    /// <summary>
    /// Updates a single row in the grid by finding it by ID and updating its properties in place.
    /// This provides a smoother UX than reloading the entire grid by preserving the object reference.
    /// </summary>
    public async Task UpdateRowAsync<TKey>(TItem updatedItem, Func<TItem, TKey> keySelector) where TKey : IEquatable<TKey>
    {
        if (updatedItem == null || keySelector == null) return;
        
        var updatedKey = keySelector(updatedItem);
        
        // Find the item to update (by reference, not index)
        var existingItem = _items.FirstOrDefault(item => keySelector(item).Equals(updatedKey));
        
        if (existingItem != null)
        {
            // Update properties in place to preserve object reference
            // This prevents RadzenDataGrid from treating it as a new collection
            CopyProperties(updatedItem, existingItem);
            
            // Just call StateHasChanged - Radzen should detect the property changes
            // without reloading the entire grid since we kept the same object reference
            await InvokeAsync(StateHasChanged);
        }
        else
        {
            // Item not found in current page, do a full refresh
            await RefreshAsync();
        }
    }
    
    /// <summary>
    /// Copies properties from source to target using reflection
    /// </summary>
    private void CopyProperties(TItem source, TItem target)
    {
        if (source == null || target == null) return;
        
        var properties = typeof(TItem).GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
        
        foreach (var prop in properties)
        {
            // Skip read-only properties and navigation properties
            if (!prop.CanWrite || prop.Name.Contains("Entries") || prop.Name.Contains("Sessions") || prop.Name.Contains("Assignments"))
                continue;
                
            try
            {
                var value = prop.GetValue(source);
                prop.SetValue(target, value);
            }
            catch
            {
                // Ignore properties that can't be copied
            }
        }
    }

    private async Task LoadData(LoadDataArgs args)
    {
        if (_isLoading)
        {
            return;
        }

        _isLoading = true;
        _errorMessage = null;

        try
        {
            if (LoadItemsPaged is not null)
            {
                // Server-side pagination
                var skip = args.Skip ?? 0;
                var take = args.Top ?? PageSize;
                
                var result = await LoadItemsPaged(
                    skip,
                    take,
                    args.OrderBy,
                    args.Filter,
                    _cts?.Token ?? CancellationToken.None
                );

                // Create a new list reference so Radzen detects the change
                // IMPORTANT: When using LoadData, RadzenDataGrid uses the Data property
                // We must assign a new list reference for Radzen to detect the change
                _items = result.Items?.ToList() ?? new List<TItem>();
                _totalCount = result.TotalCount;

                if (OnItemsLoaded.HasDelegate)
                {
                    await OnItemsLoaded.InvokeAsync(_items);
                }
                
                // Force UI update - Radzen needs to see the Data property change
                // We must call StateHasChanged to trigger re-render
                await InvokeAsync(StateHasChanged);
            }
            else if (LoadItems is not null)
            {
                // Fallback to client-side pagination for backward compatibility
                var allItems = await LoadItems(_cts?.Token ?? CancellationToken.None);
                var itemsList = allItems?.ToList() ?? new();
                
                // Apply client-side filtering and sorting
                if (!string.IsNullOrEmpty(args.Filter))
                {
                    // Note: Client-side filtering would need to be implemented
                    // For now, we'll just load all items
                }

                if (!string.IsNullOrEmpty(args.OrderBy))
                {
                    // Note: Client-side sorting would need to be implemented
                    // For now, we'll just load all items
                }

                // Apply pagination
                var skip = args.Skip ?? 0;
                var take = args.Top ?? PageSize;
                _items = itemsList.Skip(skip).Take(take).ToList();
                _totalCount = itemsList.Count;

                if (OnItemsLoaded.HasDelegate)
                {
                    await OnItemsLoaded.InvokeAsync(_items);
                }
            }
        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
            _items = new();
            _totalCount = 0;
            if (OnLoadError.HasDelegate)
            {
                await OnLoadError.InvokeAsync(ex);
            }
        }
        finally
        {
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task InvokeRowActionAsync(SMDataGridActionButton<TItem> action, TItem row)
    {
        try
        {
            if (action.OnClick is null) return;

            if (_cts is null)
            {
                _cts = new CancellationTokenSource();
            }

            await action.OnClick(row, _cts.Token);
        }
        catch (OperationCanceledException)
        {
            // Swallow cancellations silently
        }
        catch (Exception ex)
        {
            _errorMessage = "An unexpected error occurred.";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleRowExpand(TItem item)
    {
        if (OnRowExpandCallback.HasDelegate)
        {
            await OnRowExpandCallback.InvokeAsync(item);
        }
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
    }

    // Public API
    /// <summary>
    /// Server-side pagination delegate. Parameters: skip, take, orderBy, filter, cancellationToken
    /// Returns a PagedResult with Items and TotalCount.
    /// </summary>
    [Parameter] public Func<int, int, string?, string?, CancellationToken, Task<PagedResult<TItem>>>? LoadItemsPaged { get; set; }
    
    /// <summary>
    /// Client-side pagination delegate (for backward compatibility).
    /// Loads all items at once - not recommended for large datasets.
    /// </summary>
    [Parameter] public Func<CancellationToken, Task<IEnumerable<TItem>>>? LoadItems { get; set; }
    
    [Parameter] public EventCallback<IReadOnlyList<TItem>> OnItemsLoaded { get; set; }
    [Parameter] public EventCallback<Exception> OnLoadError { get; set; }
    [Parameter] public bool AutoLoad { get; set; } = true;
    [Parameter] public bool ShowErrorAlert { get; set; } = true;
    [Parameter] public bool DisableActionsWhileLoading { get; set; } = true;

    [Parameter] public List<SMDataGridColumn<TItem>>? Columns { get; set; }
    [Parameter] public List<SMDataGridActionButton<TItem>>? Actions { get; set; }
    [Parameter] public string ActionsTitle { get; set; } = "Actions";
    [Parameter] public string? ActionsWidth { get; set; } = "90px";
    [Parameter] public TextAlign ActionsTextAlign { get; set; } = TextAlign.Center;

    [Parameter] public string? Class { get; set; } = "rz-mt-2";
    [Parameter] public bool AllowAlternatingRows { get; set; } = true;
    [Parameter] public bool AllowFiltering { get; set; } = true;
    [Parameter] public DataGridGridLines GridLines { get; set; } = DataGridGridLines.Both;
    [Parameter] public bool AllowColumnResize { get; set; } = true;
    [Parameter] public FilterMode FilterMode { get; set; } = FilterMode.Advanced;
    [Parameter] public bool AllowSorting { get; set; } = true;
    [Parameter] public int PageSize { get; set; } = 10;
    [Parameter] public bool AllowPaging { get; set; } = true;
    [Parameter] public HorizontalAlign PagerHorizontalAlign { get; set; } = HorizontalAlign.Left;
    [Parameter] public bool ShowPagingSummary { get; set; } = true;
    [Parameter] public string? ColumnWidth { get; set; } = "300px";
    [Parameter] public LogicalFilterOperator LogicalFilterOperator { get; set; } = LogicalFilterOperator.Or;
    [Parameter] public DataGridSelectionMode SelectionMode { get; set; } = DataGridSelectionMode.Single;

    [Parameter] public RenderFragment<TItem>? ExpansionTemplate { get; set; }
    [Parameter] public EventCallback<TItem> OnRowExpandCallback { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
}
