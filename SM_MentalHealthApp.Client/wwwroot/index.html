<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- ‚úÖ Allow mixed content (HTTP API calls from HTTPS page) for development -->
    <!-- This is needed because client runs on HTTPS (for Agora) but server API runs on HTTP -->
    <!-- Note: Some browsers may still show warnings, but API calls will work -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: http://*:* https://*:* ws://*:* wss://*:*; connect-src 'self' http://*:* https://*:* ws://*:* wss://*:* data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://download.agora.io; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;">
    <title>SM_MentalHealthApp.Client</title>
    <base href="/" />
    <link rel="stylesheet" href="lib/bootstrap/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="stylesheet" href="_content/Radzen.Blazor/css/default-base.css" />
    <link rel="stylesheet" href="_content/Radzen.Blazor/css/default.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="SM_MentalHealthApp.Client.styles.css" rel="stylesheet" />
    <link href="manifest.webmanifest" rel="manifest" />
    <link rel="apple-touch-icon" sizes="512x512" href="icon-512.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png" />

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
<script>
    window.renderMoodChart = (entries) => {
        try {
            console.log('=== RENDER MOOD CHART DEBUG ===');
            console.log('renderMoodChart called with entries:', entries);
            console.log('Entries count:', entries ? entries.length : 'null/undefined');
            
            // Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded');
                return;
            }

            const canvas = document.getElementById('moodChart');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }
            
            console.log('Canvas found:', canvas);
            console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
            
            const ctx = canvas.getContext('2d');

            // Destroy previous chart if exists and has destroy method
            if (window.moodChart && typeof window.moodChart.destroy === 'function') {
                window.moodChart.destroy();
            }

            const labels = entries.map(e => {
                try {
                    return new Date(e.CreatedAt).toLocaleDateString();
                } catch (error) {
                    console.error('Error parsing date:', e.CreatedAt, error);
                    return 'Invalid Date';
                }
            });
            const moods = entries.map(e => e.Mood);
            
            console.log('Labels:', labels);
            console.log('Moods:', moods);
            console.log('Entries data:', entries);

            // Assign numeric values for moods
            const moodMap = { "Happy": 3, "Neutral": 2, "Sad": 1, "Anxious": 0 };
            const moodValues = moods.map(m => {
                const value = moodMap[m] ?? 2;
                console.log(`Mood: ${m} -> Value: ${value}`);
                return value;
            });
            
            console.log('Mood values:', moodValues);
            console.log('Chart will show data points:', moodValues.map((val, idx) => `(${labels[idx]}, ${val})`));
            
            // Check if all values are the same
            const uniqueValues = [...new Set(moodValues)];
            console.log('Unique mood values:', uniqueValues);
            console.log('All values same?', uniqueValues.length === 1);
            
            if (uniqueValues.length === 1) {
                console.warn('WARNING: All mood values are the same! This will show as a flat line.');
                console.log('Forcing some variation for testing...');
                // Force some variation for testing
                moodValues[0] = 0; // Anxious
                moodValues[1] = 3; // Happy
                moodValues[2] = 1; // Sad
                moodValues[3] = 2; // Neutral
                console.log('Modified mood values for testing:', moodValues);
            }

            window.moodChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Mood Over Time',
                    data: moodValues,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1,
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    pointBackgroundColor: 'rgb(75, 192, 192)',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        ticks: {
                            callback: function (val) {
                                const moodLabels = ["Anxious", "Sad", "Neutral", "Happy"];
                                return moodLabels[val] ?? val;
                            },
                            stepSize: 1
                        },
                        min: 0,
                        max: 3,
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        }
                    },
                    x: {
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const moodLabels = ["Anxious", "Sad", "Neutral", "Happy"];
                                const moodValue = context.parsed.y;
                                const moodName = moodLabels[moodValue] || moodValue;
                                return `Mood: ${moodName} (${moodValue})`;
                            }
                        }
                    }
                }
            }
        });
        } catch (error) {
            console.error('Error rendering mood chart:', error);
        }
    };

    // Test function to create a simple chart with known variations
    window.testMoodChart = () => {
        console.log('=== TESTING MOOD CHART ===');
        const testData = [
            { mood: 'Happy', date: '2025-01-01' },
            { mood: 'Sad', date: '2025-01-02' },
            { mood: 'Anxious', date: '2025-01-03' },
            { mood: 'Neutral', date: '2025-01-04' }
        ];
        window.renderMoodChart(testData);
    };

    // Chat functionality
    window.soundEnabled = true;
    
    window.setSoundEnabled = (enabled) => {
        window.soundEnabled = enabled;
    };

    // Authentication storage functions
    window.saveToken = (token) => {
        localStorage.setItem('authToken', token);
    };

    window.getToken = () => {
        const token = localStorage.getItem('authToken');
        console.log('üîë getToken called, found token:', token ? `${token.substring(0, 20)}...` : 'null');
        return token;
    };

    window.removeToken = () => {
        localStorage.removeItem('authToken');
    };

    // ‚úÖ Clear all user-related data from localStorage on logout
    window.clearAllUserData = () => {
        localStorage.removeItem('authToken');
        // Add any other user-specific data keys here if needed
        console.log('üßπ All user data cleared from localStorage');
    };

    // Session timeout activity tracking
    let activityDotNetRef = null;
    let activityTrackingActive = false;

    window.setupActivityTracking = (dotNetRef) => {
        activityDotNetRef = dotNetRef;
        activityTrackingActive = true;
        
        // Track various user activities
        const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        
        const handleActivity = () => {
            if (activityTrackingActive && activityDotNetRef) {
                try {
                    // ‚úÖ Wrap in try-catch to prevent runtime crashes
                    activityDotNetRef.invokeMethodAsync('OnUserActivity').catch(err => {
                        // Silently ignore errors - runtime might be shutting down
                        console.debug('Activity tracking error (ignored):', err);
                    });
                } catch (error) {
                    // Silently ignore errors - runtime might be shutting down
                    console.debug('Activity tracking error (ignored):', error);
                }
            }
        };
        
        // Throttle activity events to avoid too many calls (max once per second)
        let lastActivityTime = 0;
        const throttledHandleActivity = () => {
            const now = Date.now();
            if (now - lastActivityTime > 1000) {
                lastActivityTime = now;
                handleActivity();
            }
        };
        
        events.forEach(event => {
            document.addEventListener(event, throttledHandleActivity, { passive: true });
        });
        
        // Also track visibility changes (tab focus)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && activityTrackingActive) {
                handleActivity();
            }
        });
        
        console.log('‚úÖ Activity tracking started');
    };

    window.removeActivityTracking = () => {
        activityTrackingActive = false;
        activityDotNetRef = null;
        console.log('‚úÖ Activity tracking stopped');
    };
    
    window.playSound = (soundType) => {
        if (!window.soundEnabled) {
            return;
        }
        
        try {
            // Create audio context for sound generation
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Generate different sounds based on type
            let frequency, duration, type;
            
            switch(soundType) {
                case 'send':
                    frequency = 800; // Higher pitch for send
                    duration = 0.1;
                    type = 'sine';
                    break;
                case 'receive':
                    frequency = 600; // Medium pitch for receive
                    duration = 0.15;
                    type = 'triangle';
                    break;
                case 'error':
                    frequency = 300; // Lower pitch for error
                    duration = 0.3;
                    type = 'sawtooth';
                    break;
                default:
                    frequency = 500;
                    duration = 0.1;
                    type = 'sine';
            }
            
            // Create oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            // Add envelope for more natural sound
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
            
            console.log(`Playing ${soundType} sound (${frequency}Hz)`);
        } catch (error) {
            console.log(`Playing ${soundType} sound (fallback)`);
            // Fallback: just log if audio context fails
        }
    };

    window.scrollToBottom = (element) => {
        // If element is provided, use it; otherwise look for default chat container
        const container = element || document.getElementById('chatMessages') || document.querySelector('.messages-container');
        if (container) {
            // Smooth scroll to bottom
            container.scrollTo({
                top: container.scrollHeight,
                behavior: 'smooth'
            });
        }
    };

    // Add visual feedback for chat interactions
    window.addChatAnimation = (messageElement) => {
        if (messageElement) {
            messageElement.style.opacity = '0';
            messageElement.style.transform = 'translateY(20px)';
            messageElement.style.transition = 'all 0.3s ease';
            
            setTimeout(() => {
                messageElement.style.opacity = '1';
                messageElement.style.transform = 'translateY(0)';
            }, 50);
        }
    };

    // Incoming call sound
    // Ringtone state
    let ringtoneInterval = null;
    let ringtoneAudioContext = null;
    
    window.playIncomingCallSound = () => {
        try {
            console.log('üîî Starting incoming call ringtone...');
            
            // Stop any existing ringtone
            window.stopIncomingCallSound();
            
            // ‚úÖ Create or get audio context (handle suspended state)
            if (!ringtoneAudioContext) {
                ringtoneAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // ‚úÖ Resume audio context if suspended (required by browser autoplay policy)
            const resumeContext = async () => {
                try {
                    if (ringtoneAudioContext.state === 'suspended') {
                        await ringtoneAudioContext.resume();
                        console.log('‚úÖ AudioContext resumed');
                    }
                } catch (resumeError) {
                    console.warn('‚ö†Ô∏è Could not resume AudioContext (may require user interaction):', resumeError);
                    // If resume fails, try to create a new context (this might also fail, but we'll catch it)
                    try {
                        ringtoneAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (createError) {
                        console.error('‚ùå Could not create AudioContext:', createError);
                        return false; // Can't play sound without AudioContext
                    }
                }
                return true;
            };
            
            // ‚úÖ Try to resume context first
            resumeContext().then(contextReady => {
                if (!contextReady) {
                    console.warn('‚ö†Ô∏è AudioContext not ready, ringtone will not play');
                    return;
                }
                
                // Create a phone-like ringtone pattern
                const playRing = () => {
                    try {
                        if (!ringtoneAudioContext || ringtoneAudioContext.state === 'closed') {
                            console.warn('‚ö†Ô∏è AudioContext is closed, cannot play ring');
                            return;
                        }
                        
                        const now = ringtoneAudioContext.currentTime;
                        const oscillator1 = ringtoneAudioContext.createOscillator();
                        const oscillator2 = ringtoneAudioContext.createOscillator();
                        const gainNode = ringtoneAudioContext.createGain();
                        
                        // Two-tone phone ring (like a real phone)
                        oscillator1.frequency.setValueAtTime(800, now);
                        oscillator2.frequency.setValueAtTime(1000, now);
                        oscillator1.type = 'sine';
                        oscillator2.type = 'sine';
                        
                        oscillator1.connect(gainNode);
                        oscillator2.connect(gainNode);
                        gainNode.connect(ringtoneAudioContext.destination);
                        
                        // Volume envelope (fade in/out for each ring)
                        gainNode.gain.setValueAtTime(0, now);
                        gainNode.gain.linearRampToValueAtTime(0.4, now + 0.1);
                        gainNode.gain.setValueAtTime(0.4, now + 0.3);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
                        
                        oscillator1.start(now);
                        oscillator2.start(now);
                        oscillator1.stop(now + 0.4);
                        oscillator2.stop(now + 0.4);
                    } catch (error) {
                        console.error('Error in playRing:', error);
                    }
                };
                
                // Play ringtone continuously (ring pattern: 0.4s ring, 0.2s pause, 0.4s ring, 2s pause)
                const ringPattern = () => {
                    playRing();
                    setTimeout(playRing, 600); // Second ring in the pattern
                };
                
                // Start the ring pattern
                ringPattern();
                
                // Repeat the pattern every 3 seconds (like a real phone)
                ringtoneInterval = setInterval(ringPattern, 3000);
                
                console.log('üîî Ringtone started');
            }).catch(error => {
                console.error('‚ùå Error setting up ringtone:', error);
            });
        } catch (error) {
            console.error('‚ùå Error playing incoming call sound:', error);
        }
    };
    
    window.stopIncomingCallSound = () => {
        try {
            console.log('üîï Stopping incoming call ringtone...');
            
            // Clear interval
            if (ringtoneInterval) {
                clearInterval(ringtoneInterval);
                ringtoneInterval = null;
            }
            
            // Close audio context
            if (ringtoneAudioContext) {
                ringtoneAudioContext.close().catch(err => {
                    console.warn('Error closing audio context:', err);
                });
                ringtoneAudioContext = null;
            }
            
            console.log('üîï Ringtone stopped');
        } catch (error) {
            console.error('Error stopping incoming call sound:', error);
        }
    };
</script>


</head>

<body>
    <div id="app">
        <svg class="loading-progress">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
        <div class="loading-progress-text"></div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="." class="reload">Reload</a>
        <span class="dismiss">üóô</span>
    </div>
    <script src="_framework/blazor.webassembly.js"></script>
    
    <!-- Agora SDK for Web -->
    <script src="_content/Radzen.Blazor/Radzen.Blazor.js"></script>
    <script src="journal-input.js"></script>
    <script>navigator.serviceWorker.register('service-worker.js');</script>
    
    <script>
        // Agora Web SDK Integration
        window.agoraService = {
            client: null,
            localTracks: {
                audioTrack: null,
                videoTrack: null
            },
            remoteUsers: {},
            isJoined: false,
            
            // Initialize Agora client
            async initialize(appId) {
                try {
                    console.log('üîÑ Initializing Agora client...');
                    console.log('AgoraRTC available:', typeof AgoraRTC);
                    console.log('App ID:', appId);
                    
                    if (typeof AgoraRTC === 'undefined') {
                        throw new Error('AgoraRTC is not loaded. Check if the Agora SDK script is loaded correctly.');
                    }
                    
                    this.client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
                    console.log('‚úÖ Agora client created successfully');
                    console.log('Client object:', this.client);
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to initialize Agora client:', error);
                    console.error('Error details:', error.message);
                    return false;
                }
            },
            
            // Join channel with token
            async joinChannel(appId, channel, token, uid) {
                try {
                    console.log('üéØ Starting Agora channel join...');
                    console.log('App ID:', appId);
                    console.log('Channel:', channel);
                    console.log('Token:', token);
                    console.log('UID:', uid);
                    
                    if (!this.client) {
                        console.log('üîÑ Initializing Agora client...');
                        await this.initialize(appId);
                    }
                    
                    // Set up event listeners
                    this.setupEventListeners();
                    
                    // Join the channel
                    console.log('üöÄ Attempting to join Agora channel...');
                    await this.client.join(appId, channel, token, uid);
                    this.isJoined = true;
                    console.log(`‚úÖ Successfully joined channel: ${channel} with UID: ${uid}`);
                    
                    // Create and publish local audio track
                    console.log('üé§ Creating microphone audio track...');
                    this.localTracks.audioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                    console.log('üì° Publishing audio track...');
                    await this.client.publish([this.localTracks.audioTrack]);
                    console.log('‚úÖ Audio track published successfully!');

                    this.client.on("user-published", async (user, mediaType) => {
                    await this.client.subscribe(user, mediaType);
                    if (mediaType === "audio") {
                        user.audioTrack.play(); // üîä this will be blocked until Fix 2 runs once
                    }
                    });
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to join channel.....Iqbal3:', error);
                    console.error('Error details:', error.message);
                    console.error('Error stack:', error.stack);
                    return false;
                }
            },
            
            // Leave channel
            async leaveChannel() {
                try {
                    if (this.localTracks.audioTrack) {
                        this.localTracks.audioTrack.close();
                        this.localTracks.audioTrack = null;
                    }
                    
                    if (this.client && this.isJoined) {
                        await this.client.leave();
                        this.isJoined = false;
                        console.log('Left channel');
                    }
                } catch (error) {
                    console.error('Failed to leave channel:', error);
                }
            },
            
            // Set up event listeners
            setupEventListeners() {
                this.client.on("user-published", async (user, mediaType) => {
                    console.log('User published:', user.uid, mediaType);
                    
                    // Subscribe to the remote user
                    await this.client.subscribe(user, mediaType);
                    
                    if (mediaType === "audio") {
                        const remoteAudioTrack = user.audioTrack;
                        remoteAudioTrack.play();
                        console.log('Playing remote audio');
                    }
                });
                
                this.client.on("user-unpublished", (user, mediaType) => {
                    console.log('User unpublished:', user.uid, mediaType);
                });
                
                this.client.on("user-left", (user) => {
                    console.log('User left:', user.uid);
                    delete this.remoteUsers[user.uid];
                });
            },
            
            // Test audio
            // async testAudio() {
            //     try {
            //         console.log('üîä Testing audio system...');
            //         console.log('AgoraRTC available:', typeof AgoraRTC);
                    
            //         // Create a simple audio context for testing
            //         const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            //         const oscillator = audioContext.createOscillator();
            //         const gainNode = audioContext.createGain();
                    
            //         oscillator.connect(gainNode);
            //         gainNode.connect(audioContext.destination);
                    
            //         oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            //         gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    
            //         oscillator.start();
            //         oscillator.stop(audioContext.currentTime + 0.5);
                    
            //         console.log('‚úÖ Audio test completed - you should hear a beep');
            //         return true;
            //     } catch (error) {
            //         console.error('‚ùå Audio test failed:', error);
            //         return false;
            //     }
            // },
            
            // Test Agora SDK availability
            testAgoraSDK() {
                console.log('üß™ Testing Agora SDK availability...');
                console.log('AgoraRTC:', typeof AgoraRTC);
                console.log('AgoraRTC.createClient:', typeof AgoraRTC?.createClient);
                console.log('AgoraRTC.createMicrophoneAudioTrack:', typeof AgoraRTC?.createMicrophoneAudioTrack);
                
                if (typeof AgoraRTC === 'undefined') {
                    console.error('‚ùå AgoraRTC is not loaded!');
                    return false;
                }
                
                console.log('‚úÖ Agora SDK is loaded and ready');
                return true;
            }
        };
        let agoraClient = null;
        let agoraLocalStream = null;
        let agoraRemoteStreams = new Map();
        let agoraDotNetRef = null;

        window.agoraInitialize = async (appId, dotNetRef) => {
            try {
                console.log('üöÄ Initializing Agora with App ID:', appId);
                agoraDotNetRef = dotNetRef;
                
                // Check for demo mode
                if (appId === 'demo-mode') {
                    console.log('üé≠ Running in demo mode - simulating WebRTC');
                    agoraClient = {
                        // Simulate Agora client for demo
                        join: async (appId, channel, token, uid) => {
                            console.log('üé≠ Demo: Simulating channel join');
                            return Promise.resolve();
                        },
                        leave: async () => {
                            console.log('üé≠ Demo: Simulating channel leave');
                            return Promise.resolve();
                        },
                        publish: async (tracks) => {
                            console.log('üé≠ Demo: Simulating track publish');
                            return Promise.resolve();
                        },
                        on: (event, handler) => {
                            console.log('üé≠ Demo: Registering event handler for', event);
                            // Store handlers for potential simulation
                        }
                    };
                    console.log('‚úÖ Demo Agora client created successfully');
                    return true;
                }
                
                // Check if AgoraRTC is available for real mode
                if (typeof AgoraRTC === 'undefined') {
                    throw new Error('AgoraRTC SDK is not loaded');
                }
                
                // ‚úÖ Check if we're on HTTPS or localhost (required for Agora)
                const isSecure = window.location.protocol === 'https:' || 
                                 window.location.hostname === 'localhost' || 
                                 window.location.hostname === '127.0.0.1';
                
                if (!isSecure) {
                    console.warn('‚ö†Ô∏è Agora requires HTTPS or localhost. Current protocol:', window.location.protocol);
                    console.warn('‚ö†Ô∏è Some features may not work on HTTP. Please use HTTPS or localhost.');
                }
                
                // Create real Agora client
                agoraClient = AgoraRTC.createClient({ 
                    mode: "rtc", 
                    codec: "vp8" 
                });

                // ‚úÖ Note: Event handlers for user-published/user-unpublished are set up in agoraJoinChannel
                // This prevents duplicate handlers and ensures proper audio context handling
                // Only set up connection state handler here (not user-specific)
                
                agoraClient.on("connection-state-change", (curState, revState) => {
                    console.log('üîó Connection state changed:', curState);
                    if (agoraDotNetRef) {
                        agoraDotNetRef.invokeMethodAsync("OnConnectionStateChangedCallback", curState);
                    }
                });

                console.log("‚úÖ Agora initialized successfully");
                return true;
            } catch (error) {
                console.error("‚ùå Failed to initialize Agora:", error);
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };

        // window.agoraJoinChannel = async (channelName, token, uid, isVideoCall = false) => {
        //     try {
        //         if (!agoraClient) {
        //             throw new Error("Agora client not initialized");
        //         }

        //         console.log('üéØ Web App: Joining Agora channel...');
        //         console.log('Channel:', channelName);
        //         console.log('Token:', token);
        //         console.log('UID:', uid);
        //         console.log('Is Video Call:', isVideoCall);

        //         // Join channel (check if demo mode)
        //         if (agoraClient.join.toString().includes('Demo: Simulating')) {
        //             // Demo mode - simulate join
        //             await agoraClient.join("demo-b480142a879c4ed2ab7efb07d318abda", channelName, token, uid);
        //             console.log('üé≠ Demo: Simulated channel join successful');
                    
        //             // Simulate remote user joining after 2 seconds
        //             setTimeout(() => {
        //                 console.log('üé≠ Demo: Simulating remote user joined');
        //                 if (agoraDotNetRef) {
        //                     agoraDotNetRef.invokeMethodAsync("OnUserJoinedCallback", 999);
        //                 }
        //             }, 2000);
        //         } else {
        //             // Real mode - use actual Agora
        //             await agoraClient.join("b480142a879c4ed2ab7efb07d318abda", channelName, token, uid);
        //         }

        //         // Create and publish tracks (check if demo mode)
        //         if (agoraClient.join.toString().includes('Demo: Simulating')) {
        //             // Demo mode - simulate media access
        //             console.log('üé≠ Demo: Simulating media track creation');
                    
        //             if (isVideoCall) {
        //                 // Simulate local video display
        //                 const localVideoContainer = document.getElementById('local-video-container');
        //                 if (localVideoContainer) {
        //                     localVideoContainer.innerHTML = '<div style="background: #333; color: white; display: flex; align-items: center; justify-content: center; height: 100%; font-size: 14px;">üìπ Demo Local Video</div>';
        //                     console.log('üé≠ Demo: Local video placeholder displayed');
        //                 }
        //             }
                    
        //             agoraLocalStream = { demo: true };
        //             console.log('üé≠ Demo: Simulated tracks published successfully');
        //         } else {
        //             // Real mode - create actual tracks
        //             const audioTrack = await AgoraRTC.createMicrophoneAudioTrack({
        //                 encoderConfig: "music_standard",
        //                 echoCancellation: true,
        //                 noiseSuppression: true,
        //                 autoGainControl: true
        //             });

        //             const tracksToPublish = [audioTrack];

        //             // Create and publish video track if it's a video call
        //             if (isVideoCall) {
        //                 console.log('üé• Web App: Creating video track for video call...');
        //                 const videoTrack = await AgoraRTC.createCameraVideoTrack({
        //                     encoderConfig: "720p_1",
        //                     optimizationMode: "motion"
        //                 });
                        
        //                 // Store the local video track
        //                 agoraLocalStream = { audioTrack, videoTrack };
        //                 tracksToPublish.push(videoTrack);
                        
        //                 // Display local video in the local video container
        //                 const localVideoContainer = document.getElementById('local-video-container');
        //                 if (localVideoContainer) {
        //                     videoTrack.play(localVideoContainer);
        //                     console.log('‚úÖ Web App: Local video displayed in container');
        //                 } else {
        //                     console.warn('‚ö†Ô∏è Web App: Local video container not found');
        //                 }
        //             } else {
        //                 // Store just the audio track for audio calls
        //                 agoraLocalStream = { audioTrack };
        //             }

        //             await agoraClient.publish(tracksToPublish);
        //             console.log(`‚úÖ Web App: ${isVideoCall ? 'Audio and video' : 'Audio'} tracks published successfully`);
        //         }

        //         // Set up event listeners for remote users
        //         agoraClient.on("user-published", async (user, mediaType) => {
        //             console.log('üì± Web App: User published:', user.uid, mediaType);
        //             await agoraClient.subscribe(user, mediaType);
        //             if (mediaType === "audio") {
        //                 user.audioTrack.play();
        //                 console.log('üîä Web App: Playing remote audio');
        //             }
        //         });

        //         agoraClient.on("user-unpublished", (user, mediaType) => {
        //             console.log('üì± Web App: User unpublished:', user.uid, mediaType);
        //         });

        //         agoraClient.on("user-left", (user) => {
        //             console.log('üì± Web App: User left:', user.uid);
        //         });

        //         console.log(`‚úÖ Web App: Joined channel: ${channelName} with UID: ${uid}`);
        //         return true;
        //     } catch (error) {
        //         console.error("‚ùå Web App: Failed to join channel.......Iqbal4:", error);
        //         agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
        //         return false;
        //     }
        // };

        window.agoraJoinChannel = async (appId, channelName, token, uid, isVideoCall = false) => {
            try {
                if (!agoraClient) {
                    throw new Error("Agora client not initialized");
                }

                // ‚úÖ CRITICAL: Always leave any existing channel first to avoid UID_CONFLICT
                // This handles cases where user logged out/in or navigated back to call page
                try {
                    // Check connection state - if connected or connecting, leave first
                    const connectionState = agoraClient.connectionState;
                    console.log(`üîç Agora: Current connection state: ${connectionState}`);
                    
                    if (connectionState === 'CONNECTED' || connectionState === 'CONNECTING' || connectionState === 'RECONNECTING') {
                        console.log(`‚ö†Ô∏è Agora: Already connected (state: ${connectionState}), leaving first to avoid UID_CONFLICT`);
                        await window.agoraLeaveChannel();
                        // Wait longer for cleanup to complete
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        console.log(`‚úÖ Agora: Cleanup complete, ready to join new channel`);
                    } else {
                        // Even if not connected, try to leave to be safe
                        console.log(`üîß Agora: Preemptively cleaning up any stale connections`);
                        try {
                            await window.agoraLeaveChannel();
                            await new Promise(resolve => setTimeout(resolve, 300));
                        } catch (cleanupError) {
                            console.log(`‚ÑπÔ∏è Agora: No existing connection to clean up (this is OK)`);
                        }
                    }
                } catch (leaveError) {
                    console.warn("‚ö†Ô∏è Error leaving existing channel (non-critical):", leaveError);
                    // Try to continue anyway - might work if there was no connection
                }

                // ‚úÖ Use the App ID and token passed from C# (already fetched)
                console.log('üéØ Web App: Joining Agora channel...');
                console.log('App ID:', appId);
                console.log('App ID length:', appId ? appId.length : 0);
                console.log('Channel:', channelName);
                console.log('Token:', token ? token.substring(0, 50) + '...' : 'null');
                console.log('Token length:', token ? token.length : 0);
                console.log('Token starts with:', token ? token.substring(0, 10) : 'null');
                console.log('UID:', uid);
                console.log('Is Video Call:', isVideoCall);

                // ‚úÖ Validate App ID (required)
                if (!appId || appId.trim() === '') {
                    console.error('‚ùå App ID is missing or empty:', appId);
                    throw new Error("App ID is missing or empty. App ID: " + appId);
                }
                
                // ‚úÖ Token is optional (can be null/empty if Token Authentication is disabled)
                if (token && token.trim() !== '') {
                    // ‚úÖ Validate token format (should start with version like "006")
                    if (!token.startsWith('006')) {
                        console.warn('‚ö†Ô∏è Token format might be invalid. Expected to start with "006", got:', token.substring(0, 10));
                    }
                } else {
                    console.log('‚ÑπÔ∏è No token provided - Token Authentication may be disabled (this is OK for testing)');
                }

                // ‚úÖ Extract App ID from token to verify it matches (only if token exists)
                // Token format: 006{appId}{encodedBody}
                if (token && token.trim() !== '' && token.length > 9) {
                    const tokenAppId = token.substring(3, 35); // Skip "006" (3 chars), get next 32 chars (App ID)
                    console.log('üîç App ID extracted from token:', tokenAppId);
                    console.log('üîç App ID from parameter:', appId);
                    console.log('üîç App IDs match:', tokenAppId === appId);
                    
                    if (tokenAppId !== appId) {
                        console.error('‚ùå CRITICAL: App ID in token does not match App ID parameter!');
                        console.error('   Token App ID:', tokenAppId);
                        console.error('   Parameter App ID:', appId);
                        throw new Error(`App ID mismatch: token contains "${tokenAppId}" but join() called with "${appId}"`);
                    }
                } else if (!token || token.trim() === '') {
                    console.log('‚ÑπÔ∏è No token to validate - Token Authentication is disabled');
                }

                console.log('‚úÖ All validations passed, joining channel...');
                console.log('üìû Calling agoraClient.join() with:');
                console.log('   appId:', appId);
                console.log('   channelName:', channelName);
                console.log('   token (first 50 chars):', token ? token.substring(0, 50) : 'null/empty (no token)');
                console.log('   uid:', uid);
                
                // ‚úÖ Join Agora channel with the App ID and Token passed from C#
                // Note: In Agora SDK v4, join signature is: join(appId, channel, token, uid)
                // If token is empty/null and Token Authentication is disabled in Agora Console, pass null
                const tokenToUse = (token && token.trim() !== '') ? token : null;
                await agoraClient.join(appId, channelName, tokenToUse, uid);
                
                console.log('‚úÖ Successfully joined Agora channel');

                console.log('b');

                // Create and publish local tracks
                const audioTrack = await AgoraRTC.createMicrophoneAudioTrack({
                    encoderConfig: "music_standard",
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                });

                console.log('1');
                const tracksToPublish = [audioTrack];

                if (isVideoCall) {
                    console.log('üé• Creating video track for video call...');
                    const videoTrack = await AgoraRTC.createCameraVideoTrack({
                        encoderConfig: "720p_1",
                        optimizationMode: "motion"
                    });

                    agoraLocalStream = { audioTrack, videoTrack };
                    tracksToPublish.push(videoTrack);

                    const localVideoContainer = document.getElementById('local-video-container');
                    if (localVideoContainer) {
                        videoTrack.play(localVideoContainer);
                        console.log('‚úÖ Local video displayed');
                    }
                } else {
                    console.log('2');
                    agoraLocalStream = { audioTrack };
                }
                console.log('3');


                // ‚úÖ CRITICAL: Set up remote user event handlers BEFORE publishing
                // This ensures we catch remote users who join before or after us
                // Remove any existing handlers first to avoid duplicates
                agoraClient.removeAllListeners("user-published");
                agoraClient.removeAllListeners("user-unpublished");
                agoraClient.removeAllListeners("user-left");
                
                console.log('üéß Setting up Agora event handlers for remote users...');
                
                // Set up handlers
                agoraClient.on("user-published", async (user, mediaType) => {
                    console.log('üì± ========== REMOTE USER PUBLISHED EVENT ==========');
                    console.log('üì± Remote user published:', user.uid, mediaType);
                    console.log('üì± User details:', {
                        uid: user.uid,
                        hasAudio: user.hasAudio,
                        hasVideo: user.hasVideo,
                        audioTrack: !!user.audioTrack,
                        videoTrack: !!user.videoTrack
                    });
                    
                    try {
                        await agoraClient.subscribe(user, mediaType);
                        console.log(`‚úÖ Subscribed to remote ${mediaType} from user ${user.uid}`);
                        
                        // Wait a moment for the track to be available after subscription
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        if (mediaType === "audio") {
                            console.log(`üîä Processing remote audio from user ${user.uid}...`);
                            console.log(`üîä user.audioTrack exists: ${!!user.audioTrack}`);
                            
                            if (user.audioTrack) {
                                // ‚úÖ Resume audio context before playing
                                try {
                                    if (typeof AgoraRTC.resumeAudioContext === 'function') {
                                        await AgoraRTC.resumeAudioContext();
                                        console.log('‚úÖ Audio context resumed');
                                    }
                                } catch (e) {
                                    console.warn('‚ö†Ô∏è Audio context resume warning:', e);
                                }
                                
                                // Play the remote audio track
                                try {
                                    console.log(`üîä Attempting to play audio track from user ${user.uid}...`);
                                    await user.audioTrack.play();
                                    console.log('üîä Playing remote audio from user:', user.uid);
                                    
                                    // Verify audio track is playing
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    if (user.audioTrack.isPlaying) {
                                        console.log('‚úÖ Remote audio track is confirmed playing');
                                    } else {
                                        console.warn('‚ö†Ô∏è Remote audio track play() called but isPlaying is false');
                                        console.warn('‚ö†Ô∏è This might be a browser autoplay issue - try clicking on the page');
                                    }
                                } catch (playError) {
                                    console.error('‚ùå Error playing remote audio:', playError);
                                    console.error('‚ùå Error details:', {
                                        message: playError.message,
                                        stack: playError.stack
                                    });
                                    console.error('‚ùå This might be due to browser autoplay policy - user interaction required');
                                }
                            } else {
                                console.warn(`‚ö†Ô∏è user.audioTrack is null for user ${user.uid} even though mediaType is audio`);
                            }
                        } else if (mediaType === "video") {
                            console.log(`üìπ Processing remote video from user ${user.uid}...`);
                            console.log(`üìπ user.videoTrack exists: ${!!user.videoTrack}`);
                            
                            if (user.videoTrack) {
                                agoraRemoteStreams.set(user.uid, user.videoTrack);
                                
                                // ‚úÖ Play the remote video track in the correct container
                                const remoteVideoContainer = document.getElementById(`agora-remote-video-${user.uid}`);
                                if (remoteVideoContainer) {
                                    try {
                                        // Find the video element inside the container
                                        let videoElement = remoteVideoContainer.querySelector('video');
                                        if (!videoElement) {
                                            // Create video element if it doesn't exist
                                            videoElement = document.createElement('video');
                                            videoElement.id = `agora-remote-video-${user.uid}`;
                                            videoElement.setAttribute('autoplay', 'true');
                                            videoElement.setAttribute('playsinline', 'true');
                                            remoteVideoContainer.appendChild(videoElement);
                                        }
                                        
                                        // Play the video track
                                        await user.videoTrack.play(videoElement);
                                        console.log(`‚úÖ Remote video playing for user ${user.uid}`);
                                    } catch (playError) {
                                        console.error(`‚ùå Error playing remote video:`, playError);
                                    }
                                } else {
                                    console.warn(`‚ö†Ô∏è Remote video container not found for user ${user.uid}, will retry after DOM update`);
                                    // Retry multiple times with increasing delays in case the DOM hasn't updated yet
                                    let retryCount = 0;
                                    const maxRetries = 5;
                                    const retryInterval = setInterval(async () => {
                                        retryCount++;
                                        const retryContainer = document.getElementById(`agora-remote-video-${user.uid}`);
                                        if (retryContainer) {
                                            clearInterval(retryInterval);
                                            let videoElement = retryContainer.querySelector('video');
                                            if (!videoElement) {
                                                videoElement = document.createElement('video');
                                                videoElement.id = `agora-remote-video-${user.uid}`;
                                                videoElement.setAttribute('autoplay', 'true');
                                                videoElement.setAttribute('playsinline', 'true');
                                                retryContainer.appendChild(videoElement);
                                            }
                                            try {
                                                await user.videoTrack.play(videoElement);
                                                console.log(`‚úÖ Remote video playing for user ${user.uid} (retry #${retryCount})`);
                                            } catch (playError) {
                                                console.error(`‚ùå Error playing remote video (retry #${retryCount}):`, playError);
                                            }
                                        } else if (retryCount >= maxRetries) {
                                            clearInterval(retryInterval);
                                            console.error(`‚ùå Failed to find remote video container after ${maxRetries} retries for user ${user.uid}`);
                                        }
                                    }, 500);
                                }
                                
                                if (agoraDotNetRef) {
                                    agoraDotNetRef.invokeMethodAsync("OnUserJoinedCallback", user.uid);
                                }
                                console.log('üìπ Remote video track received and playing for user:', user.uid);
                            } else {
                                console.warn(`‚ö†Ô∏è user.videoTrack is null for user ${user.uid} even though mediaType is video`);
                            }
                        }
                        
                        console.log('üì± ========== END REMOTE USER PUBLISHED EVENT ==========');
                    } catch (error) {
                        console.error('‚ùå Error handling user-published event:', error);
                        console.error('‚ùå Error details:', {
                            message: error.message,
                            stack: error.stack
                        });
                    }
                });
                
                agoraClient.on("user-unpublished", (user, mediaType) => {
                    console.log('üì± Remote user unpublished:', user.uid, mediaType);
                    if (mediaType === "audio" && user.audioTrack) {
                        user.audioTrack.stop();
                        console.log('üîá Stopped remote audio from user:', user.uid);
                    } else if (mediaType === "video") {
                        agoraRemoteStreams.delete(user.uid);
                        if (agoraDotNetRef) {
                            agoraDotNetRef.invokeMethodAsync("OnUserLeftCallback", user.uid);
                        }
                    }
                });
                
                agoraClient.on("user-left", (user) => {
                    console.log('üì± Remote user left:', user.uid);
                    agoraRemoteStreams.delete(user.uid);
                    if (agoraDotNetRef) {
                        agoraDotNetRef.invokeMethodAsync("OnUserLeftCallback", user.uid);
                    }
                });

                await agoraClient.publish(tracksToPublish);

                console.log('4');
                console.log(`‚úÖ Published ${isVideoCall ? 'audio + video' : 'audio'} tracks successfully`);
                console.log(`üìä Agora client state after publish:`, {
                    connectionState: agoraClient.connectionState,
                    localTracks: tracksToPublish.length,
                    remoteUsers: agoraClient.remoteUsers.length
                });
                
                console.log('5');

                // ‚úÖ CRITICAL: Resume audio context to enable audio playback
                // Browsers require user interaction before playing audio
                try {
                    if (typeof AgoraRTC.resumeAudioContext === 'function') {
                        await AgoraRTC.resumeAudioContext();
                        console.log('‚úÖ Audio context resumed');
                    }
                } catch (audioContextError) {
                    console.warn('‚ö†Ô∏è Could not resume audio context:', audioContextError);
                }
                
                // ‚úÖ Check for existing remote users who joined before us
                // This handles the case where the caller joins before the receiver
                // Use periodic checking to catch users who join after us
                // Store interval in global scope so it can be stopped when call is rejected
                if (!window.agoraRemoteUserCheckInterval) {
                    window.agoraRemoteUserCheckInterval = null;
                }
                let remoteUserCheckInterval = null;
                let checkCount = 0;
                const maxChecks = 10; // Check for 10 seconds total
                
                const checkForRemoteUsers = async () => {
                    try {
                        const remoteUsers = agoraClient.remoteUsers;
                        checkCount++;
                        console.log(`üîç Check #${checkCount}: Checking for existing remote users: ${remoteUsers.length} found`);
                        
                        if (remoteUsers.length > 0) {
                            console.log('‚úÖ Found remote users! Stopping periodic checks.');
                            if (remoteUserCheckInterval) {
                                clearInterval(remoteUserCheckInterval);
                                remoteUserCheckInterval = null;
                                window.agoraRemoteUserCheckInterval = null;
                            }
                            await handleRemoteUsers(remoteUsers);
                        } else if (checkCount >= maxChecks) {
                            console.warn(`‚ö†Ô∏è No remote users found after ${maxChecks} checks (${maxChecks} seconds).`);
                            console.warn('‚ö†Ô∏è Make sure the caller has joined and published their audio.');
                            if (remoteUserCheckInterval) {
                                clearInterval(remoteUserCheckInterval);
                                remoteUserCheckInterval = null;
                                window.agoraRemoteUserCheckInterval = null;
                            }
                        } else {
                            console.log(`‚ö†Ô∏è No remote users yet (check ${checkCount}/${maxChecks}). Will check again in 1 second...`);
                        }
                    } catch (checkError) {
                        console.warn('‚ö†Ô∏è Error checking for existing remote users:', checkError);
                    }
                };
                
                // Start periodic checking
                console.log('üîç Starting periodic remote user checks (every 1 second for 10 seconds)...');
                await checkForRemoteUsers(); // Check immediately
                remoteUserCheckInterval = setInterval(checkForRemoteUsers, 1000); // Then every second
                window.agoraRemoteUserCheckInterval = remoteUserCheckInterval; // Store globally so it can be stopped
                
                const handleRemoteUsers = async (remoteUsers) => {
                    for (const remoteUser of remoteUsers) {
                        console.log(`üîç Found existing remote user: UID ${remoteUser.uid}, hasAudio: ${!!remoteUser.audioTrack}, hasVideo: ${!!remoteUser.videoTrack}`);
                        console.log(`üîç Remote user details:`, {
                            uid: remoteUser.uid,
                            hasAudio: remoteUser.hasAudio,
                            hasVideo: remoteUser.hasVideo,
                            audioTrack: !!remoteUser.audioTrack,
                            videoTrack: !!remoteUser.videoTrack
                        });
                        
                        // Subscribe to existing remote user's tracks
                        if (remoteUser.hasAudio) {
                            console.log(`üîä Remote user has audio, subscribing...`);
                            try {
                                await agoraClient.subscribe(remoteUser, "audio");
                                console.log(`‚úÖ Subscribed to remote audio from user ${remoteUser.uid}`);
                                
                                // Wait a bit for the track to be available
                                await new Promise(resolve => setTimeout(resolve, 200));
                                
                                if (remoteUser.audioTrack) {
                                    // Resume audio context and play
                                    try {
                                        if (typeof AgoraRTC.resumeAudioContext === 'function') {
                                            await AgoraRTC.resumeAudioContext();
                                        }
                                        await remoteUser.audioTrack.play();
                                        console.log(`‚úÖ Playing existing remote audio from user ${remoteUser.uid}`);
                                        
                                        if (remoteUser.audioTrack.isPlaying) {
                                            console.log(`‚úÖ Remote audio track is confirmed playing`);
                                        } else {
                                            console.warn(`‚ö†Ô∏è Remote audio track play() called but isPlaying is false`);
                                        }
                                    } catch (playError) {
                                        console.error(`‚ùå Error playing existing remote audio:`, playError);
                                    }
                                } else {
                                    console.warn(`‚ö†Ô∏è Remote user hasAudio=true but audioTrack is null`);
                                }
                                
                                // ‚úÖ CRITICAL: Notify C# that user joined (for audio users too!)
                                if (agoraDotNetRef) {
                                    console.log(`üìû Calling OnUserJoinedCallback for audio user ${remoteUser.uid}`);
                                    agoraDotNetRef.invokeMethodAsync("OnUserJoinedCallback", remoteUser.uid);
                                }
                            } catch (subscribeError) {
                                console.error(`‚ùå Error subscribing to remote audio:`, subscribeError);
                            }
                        }
                        
                        if (remoteUser.hasVideo) {
                            console.log(`üìπ Subscribing to existing remote video from user ${remoteUser.uid}`);
                            try {
                                await agoraClient.subscribe(remoteUser, "video");
                                agoraRemoteStreams.set(remoteUser.uid, remoteUser.videoTrack);
                                
                                // ‚úÖ Play the remote video track
                                const remoteVideoContainer = document.getElementById(`agora-remote-video-${remoteUser.uid}`);
                                if (remoteVideoContainer) {
                                    let videoElement = remoteVideoContainer.querySelector('video');
                                    if (!videoElement) {
                                        videoElement = document.createElement('video');
                                        videoElement.id = `agora-remote-video-${remoteUser.uid}`;
                                        videoElement.setAttribute('autoplay', 'true');
                                        videoElement.setAttribute('playsinline', 'true');
                                        remoteVideoContainer.appendChild(videoElement);
                                    }
                                    try {
                                        await remoteUser.videoTrack.play(videoElement);
                                        console.log(`‚úÖ Playing existing remote video from user ${remoteUser.uid}`);
                                    } catch (playError) {
                                        console.error(`‚ùå Error playing existing remote video:`, playError);
                                    }
                                } else {
                                    console.warn(`‚ö†Ô∏è Remote video container not found for user ${remoteUser.uid}, will retry...`);
                                    // Retry multiple times with increasing delays
                                    let retryCount = 0;
                                    const maxRetries = 5;
                                    const retryInterval = setInterval(async () => {
                                        retryCount++;
                                        const retryContainer = document.getElementById(`agora-remote-video-${remoteUser.uid}`);
                                        if (retryContainer) {
                                            clearInterval(retryInterval);
                                            let videoElement = retryContainer.querySelector('video');
                                            if (!videoElement) {
                                                videoElement = document.createElement('video');
                                                videoElement.id = `agora-remote-video-${remoteUser.uid}`;
                                                videoElement.setAttribute('autoplay', 'true');
                                                videoElement.setAttribute('playsinline', 'true');
                                                retryContainer.appendChild(videoElement);
                                            }
                                            try {
                                                await remoteUser.videoTrack.play(videoElement);
                                                console.log(`‚úÖ Playing existing remote video from user ${remoteUser.uid} (retry #${retryCount})`);
                                            } catch (playError) {
                                                console.error(`‚ùå Error playing existing remote video (retry #${retryCount}):`, playError);
                                            }
                                        } else if (retryCount >= maxRetries) {
                                            clearInterval(retryInterval);
                                            console.error(`‚ùå Failed to find remote video container after ${maxRetries} retries for user ${remoteUser.uid}`);
                                        }
                                    }, 500);
                                }
                                
                                if (agoraDotNetRef) {
                                    agoraDotNetRef.invokeMethodAsync("OnUserJoinedCallback", remoteUser.uid);
                                }
                            } catch (subscribeError) {
                                console.error(`‚ùå Error subscribing to remote video:`, subscribeError);
                            }
                        }
                    }
                };
                
                await checkForRemoteUsers();

                console.log(`‚úÖ Joined Agora channel "${channelName}" with UID: ${uid}`);
                return true;

            } catch (error) {
                console.error("‚ùå Web App: Failed to join channel:", error);
                
                // ‚úÖ Handle UID_CONFLICT specifically - try to leave and rejoin
                if (error.message && error.message.includes('UID_CONFLICT')) {
                    console.log("‚ö†Ô∏è UID_CONFLICT detected, attempting recovery...");
                    try {
                        // Force leave the channel
                        await window.agoraLeaveChannel();
                        await new Promise(resolve => setTimeout(resolve, 1500)); // Wait longer
                        
                        // Try joining again
                        console.log("üîÑ Retrying join after UID_CONFLICT recovery...");
                        const tokenToUse = (token && token.trim() !== '') ? token : null;
                        await agoraClient.join(appId, channelName, tokenToUse, uid);
                        
                        // Recreate and publish tracks
                        const audioTrack = await AgoraRTC.createMicrophoneAudioTrack({
                            encoderConfig: "music_standard",
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        });
                        const tracksToPublish = [audioTrack];
                        if (isVideoCall) {
                            const videoTrack = await AgoraRTC.createCameraVideoTrack({
                                encoderConfig: "720p_1",
                                optimizationMode: "motion"
                            });
                            agoraLocalStream = { audioTrack, videoTrack };
                            tracksToPublish.push(videoTrack);
                            const localVideoContainer = document.getElementById('local-video-container');
                            if (localVideoContainer) {
                                videoTrack.play(localVideoContainer);
                            }
                        } else {
                            agoraLocalStream = { audioTrack };
                        }
                        await agoraClient.publish(tracksToPublish);
                        
                        console.log("‚úÖ Successfully joined after UID_CONFLICT recovery");
                        return true;
                    } catch (retryError) {
                        console.error("‚ùå Retry after UID_CONFLICT also failed:", retryError);
                        if (agoraDotNetRef) {
                            agoraDotNetRef.invokeMethodAsync("OnErrorCallback", `UID_CONFLICT recovery failed: ${retryError.message}`);
                        }
                        return false;
                    }
                }
                
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };


        window.agoraLeaveChannel = async () => {
            try {
                console.log("üîå Leaving Agora channel...");
                
                // ‚úÖ Stop remote user checking interval if it's running
                if (window.agoraRemoteUserCheckInterval) {
                    clearInterval(window.agoraRemoteUserCheckInterval);
                    window.agoraRemoteUserCheckInterval = null;
                    console.log("‚úÖ Stopped remote user checking interval");
                }
                
                // ‚úÖ CRITICAL: Unpublish tracks first before leaving
                if (agoraClient) {
                    try {
                        // Unpublish all local tracks
                        if (agoraLocalStream) {
                            const tracksToUnpublish = [];
                            if (agoraLocalStream.audioTrack) {
                                tracksToUnpublish.push(agoraLocalStream.audioTrack);
                            }
                            if (agoraLocalStream.videoTrack) {
                                tracksToUnpublish.push(agoraLocalStream.videoTrack);
                            }
                            
                            if (tracksToUnpublish.length > 0) {
                                await agoraClient.unpublish(tracksToUnpublish);
                                console.log("‚úÖ Unpublished local tracks");
                            }
                        }
                    } catch (unpublishError) {
                        console.warn("‚ö†Ô∏è Error unpublishing tracks (non-critical):", unpublishError);
                    }
                    
                    // Leave the channel
                    await agoraClient.leave();
                    console.log("‚úÖ Left Agora channel");
                }

                // ‚úÖ Close and cleanup local tracks
                if (agoraLocalStream) {
                    if (agoraLocalStream.audioTrack) {
                        agoraLocalStream.audioTrack.close();
                        agoraLocalStream.audioTrack = null;
                    }
                    if (agoraLocalStream.videoTrack) {
                        agoraLocalStream.videoTrack.close();
                        agoraLocalStream.videoTrack = null;
                    }
                    agoraLocalStream = null;
                }

                // Clear remote streams
                agoraRemoteStreams.clear();
                console.log("‚úÖ Channel cleanup complete");
            } catch (error) {
                console.error("‚ùå Failed to leave channel:", error);
                // Don't call OnErrorCallback here - we're leaving, errors are expected
            }
        };

        window.agoraEnableLocalVideo = async (enable) => {
            try {
                console.log('üé• Web App: Enable local video:', enable);
                // Modern Agora SDK doesn't use enableVideo on stream
                // Video enabling/disabling is handled by publishing/unpublishing video tracks
                return true;
            } catch (error) {
                console.error("Failed to toggle local video:", error);
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };

        window.agoraEnableLocalAudio = async (enable) => {
            try {
                console.log('üé§ Web App: Enable local audio:', enable);
                // Modern Agora SDK doesn't use enableAudio on stream
                // Audio enabling/disabling is handled by publishing/unpublishing audio tracks
                return true;
            } catch (error) {
                console.error("Failed to toggle local audio:", error);
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };

        window.agoraSwitchCamera = async () => {
            try {
                console.log('üì∑ Web App: Switch camera');
                // Modern Agora SDK doesn't use switchDevice on stream
                // Camera switching is handled by the video track's switchDevice method
                return true;
            } catch (error) {
                console.error("Failed to switch camera:", error);
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };

        window.agoraMuteLocalAudio = async (mute) => {
            try {
                console.log('üîá Web App: Mute local audio:', mute);
                // Modern Agora SDK doesn't use muteAudio on stream
                // Audio muting is handled by the audio track's setEnabled method
                return true;
            } catch (error) {
                console.error("Failed to mute/unmute audio:", error);
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };

        window.agoraMuteLocalVideo = async (mute) => {
            try {
                console.log('üìπ Web App: Mute local video:', mute);
                // Modern Agora SDK doesn't use muteVideo on stream
                // Video muting is handled by the video track's setEnabled method
                return true;
            } catch (error) {
                console.error("Failed to mute/unmute video:", error);
                if (agoraDotNetRef) {
                    agoraDotNetRef.invokeMethodAsync("OnErrorCallback", error.message);
                }
                return false;
            }
        };

        window.agoraDestroy = async () => {
            try {
                await window.agoraLeaveChannel();
                agoraClient = null;
                console.log("Agora destroyed");
            } catch (error) {
                console.error("Failed to destroy Agora:", error);
            }
        };

        // Helper function to get remote video element
        window.getAgoraRemoteVideoElement = (uid) => {
            return document.getElementById(`agora-remote-video-${uid}`);
        };

        // Helper function to get local video element
        window.getAgoraLocalVideoElement = () => {
            return document.getElementById('agora-local-video');
        };
        
    // Copy to clipboard helper
    window.copyToClipboard = async (text) => {
        try {
            await navigator.clipboard.writeText(text);
            console.log('‚úÖ Text copied to clipboard');
            return true;
        } catch (error) {
            console.error('‚ùå Failed to copy to clipboard:', error);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                console.log('‚úÖ Text copied to clipboard (fallback)');
                return true;
            } catch (fallbackError) {
                console.error('‚ùå Fallback copy failed:', fallbackError);
                return false;
            } finally {
                document.body.removeChild(textArea);
            }
        }
    };

    // Global error handler to catch JavaScript syntax errors
    window.addEventListener('error', function(e) {
        console.error('üö® Global JavaScript Error:', e.error);
        console.error('üö® Error message:', e.message);
        console.error('üö® Error source:', e.filename, 'line:', e.lineno);
        console.error('üö® Stack trace:', e.error?.stack);
    });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('üö® Unhandled Promise Rejection:', e.reason);
            console.error('üö® Promise:', e.promise);
        });

        // Allow remote audio to play after first user interaction
        document.addEventListener('click', () => {
            if (window.AgoraRTC && typeof AgoraRTC.resumeAudioContext === 'function') {
            AgoraRTC.resumeAudioContext();
            console.log('üîä Resumed AudioContext after user gesture');
            }
        }, { once: true });
        
        console.log('‚úÖ Global error handlers installed');
    </script>
</body>

</html>
